/* This file was generated by the Hex-Rays decompiler version 9.2.0.250908.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>



//----- (0000000140001001) ----------------------------------------------------
__int64 __fastcall sub_140001001(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4)
{
  __int64 v6; // r13
  unsigned int v7; // ebp
  unsigned int v8; // r12d
  __int64 v9; // r14
  __int64 v10; // r9
  __int64 v11; // r14
  bool v12; // zf

  ++*(_DWORD *)(a1 + 168);
  v6 = a2[23];
  v7 = 24 * *(_DWORD *)(a1 + 84);
  if ( v7 >= *(_DWORD *)(v6 + 8) )
    v7 = *(_DWORD *)(v6 + 8);
  v8 = v7;
  if ( v7 >= *(_DWORD *)(a1 + 104) + *(_DWORD *)(a1 + 136) - *(_DWORD *)(a1 + 120) )
    v8 = *(_DWORD *)(a1 + 104) + *(_DWORD *)(a1 + 136) - *(_DWORD *)(a1 + 120);
  v9 = a2[3];
  sub_140002780(v9, *(_QWORD *)(a1 + 120), v8, a4);
  v11 = v8 + v9;
  if ( v7 == v8 )
  {
    *(_QWORD *)(a1 + 120) += v8;
  }
  else
  {
    sub_140002780(v11, *(_QWORD *)(a1 + 104), v7 - v8, v10);
    *(_QWORD *)(a1 + 120) = v7 - v8 + *(_QWORD *)(a1 + 104);
  }
  v12 = *(_DWORD *)(a1 + 84) == v7 / 0x18;
  *(_DWORD *)(a1 + 84) -= v7 / 0x18;
  if ( v12 )
    *(_BYTE *)(a1 + 66) = 1;
  a2[7] = v7;
  *(_DWORD *)(v6 + 8) = v7;
  return 0;
}
// 140001081: variable 'v10' is possibly undefined
// 140002780: using guessed type __int64 __fastcall sub_140002780(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000001400010DB) ----------------------------------------------------
_QWORD *__fastcall sub_1400010DB(__int64 a1)
{
  _QWORD *v1; // rdx
  _QWORD **v2; // r8
  _QWORD *v3; // rcx
  _QWORD *v4; // rax

  v1 = 0;
  v2 = (_QWORD **)(a1 + 152);
  do
  {
    v3 = *v2;
    if ( *v2 == v2 )
      break;
    if ( (_QWORD **)v3[1] == v2 )
    {
      v4 = (_QWORD *)*v3;
      if ( *(_QWORD **)(*v3 + 8LL) == v3 )
        continue;
    }
    __fastfail(3u);
    *v2 = v4;
    v1 = v3 - 21;
    v4[1] = v2;
    if ( !_InterlockedExchange64(v3 - 8, 0) )
    {
      v3[1] = v3;
      v1 = 0;
      *v3 = v3;
    }
  }
  while ( !v1 );
  return v1;
}

//----- (000000014000112E) ----------------------------------------------------
__int64 **__fastcall sub_14000112E(__int64 a1, __int64 a2, int a3, _DWORD *a4)
{
  _DWORD *v4; // r13
  __int64 v6; // r14
  _DWORD *v8; // rdi
  unsigned int v9; // ebx
  unsigned __int64 v10; // r12
  __int64 v11; // rdx
  __int64 v12; // rsi
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 v15; // r13
  __int64 v16; // r8
  __int64 ***v17; // rsi
  __int64 **v18; // rax
  __int64 v19; // r14
  unsigned int v20; // ebx
  unsigned int v21; // ecx
  unsigned int v22; // r12d
  unsigned int v23; // ebx
  unsigned int v24; // esi
  __int64 v25; // r8
  __int64 v26; // r9
  __int64 v27; // r14
  unsigned __int64 v28; // rdx
  unsigned __int64 v29; // rcx
  unsigned __int64 v30; // rax
  unsigned __int64 v31; // rdx
  __int64 v32; // rax
  __int64 v33; // rbx
  _QWORD *v34; // rdx
  __int64 ***v35; // rax
  __int64 v36; // rdx
  __int64 *v37; // rbx
  __int64 **result; // rax
  __int64 *v39; // rax
  __int64 *v40; // [rsp+60h] [rbp-10h] BYREF
  __int64 **v41; // [rsp+68h] [rbp-8h]

  v4 = a4;
  v6 = a2;
  if ( (__int64 *)qword_140004000 == &qword_140004000 && *(_WORD *)(qword_140004008 + 72) )
  {
    LOBYTE(a2) = 5;
    nullsub_1(*(_QWORD *)(qword_140004008 + 64), a2, 3, 50);
  }
  v8 = *(_DWORD **)(a1 + 64);
  v9 = a3 - v6;
  LODWORD(v10) = 0;
  *v4 = 0;
  qword_140004080(v8 + 36);
  v41 = &v40;
  v40 = (__int64 *)&v40;
  v12 = sub_1400010DB(v8);
  v14 = 0;
  if ( v12 )
  {
    v15 = *(_QWORD *)(v12 + 184);
    v10 = v9;
    v16 = *(unsigned int *)(v15 + 8);
    if ( v9 >= (unsigned int)v16 )
      v10 = (unsigned int)v16;
    *a4 += v10 / 0x18;
    if ( (__int64 *)qword_140004000 == &qword_140004000 && *(_WORD *)(qword_140004008 + 72) )
      nullsub_1(*(_QWORD *)(qword_140004008 + 64), v10 / 0x18, v16, 0);
    if ( (__int64 *)qword_140004000 == &qword_140004000 )
      nullsub_1(*(_QWORD *)(qword_140004008 + 64), &qword_140004000, v16, v14);
    sub_140002780(*(_QWORD *)(v12 + 24), v6, v10, v14);
    *(_QWORD *)(v12 + 56) = v10;
    v13 = 0;
    *(_DWORD *)(v12 + 48) = 0;
    v17 = (__int64 ***)(v12 + 168);
    *(_DWORD *)(v15 + 8) = v10;
    v18 = v41;
    if ( *v41 != (__int64 *)&v40 )
LABEL_50:
      __fastfail(3u);
    v4 = a4;
    *v17 = &v40;
    v17[1] = v18;
    *v18 = (__int64 *)v17;
    v41 = (__int64 **)v17;
  }
  v19 = (unsigned int)v10 + v6;
  v20 = v9 - v10;
  if ( (__int64 *)qword_140004000 == &qword_140004000 && *(_WORD *)(qword_140004008 + 72) )
    nullsub_1(*(_QWORD *)(qword_140004008 + 64), v11, v13, v14);
  if ( v20 )
  {
    if ( (__int64 *)qword_140004000 == &qword_140004000 && *(_WORD *)(qword_140004008 + 72) )
      nullsub_1(*(_QWORD *)(qword_140004008 + 64), (unsigned int)(24 * v8[21]), v13, 54);
    v21 = v8[34];
    v22 = v21;
    if ( v21 >= v20 )
      v22 = v20;
    v23 = v21 - v8[28] + v8[26];
    if ( (__int64 *)qword_140004000 == &qword_140004000 && *(_WORD *)(qword_140004008 + 72) )
      nullsub_1(*(_QWORD *)(qword_140004008 + 64), v11, v13, 56);
    v24 = v22;
    if ( v22 >= v23 )
      v24 = v23;
    if ( (__int64 *)qword_140004000 == &qword_140004000 && *(_WORD *)(qword_140004008 + 72) )
      nullsub_1(*(_QWORD *)(qword_140004008 + 64), v11, v13, 57);
    sub_140002780(*((_QWORD *)v8 + 14), v19, v24, v14);
    *((_QWORD *)v8 + 14) += v24;
    v27 = v24 + v19;
    v28 = *((_QWORD *)v8 + 13);
    v29 = *((_QWORD *)v8 + 14);
    if ( v29 >= v28 + (unsigned int)v8[34] )
    {
      *((_QWORD *)v8 + 14) = v28;
      v29 = v28;
    }
    if ( v22 != v24 )
    {
      v30 = v29;
      if ( (__int64 *)qword_140004000 == &qword_140004000 && *(_WORD *)(qword_140004008 + 72) )
      {
        nullsub_1(*(_QWORD *)(qword_140004008 + 64), qword_140004008, 0, 58);
        v30 = *((_QWORD *)v8 + 14);
      }
      sub_140002780(v30, v27, v22 - v24, v26);
      *((_QWORD *)v8 + 14) += v22 - v24;
    }
    v31 = v22 / 0x18uLL;
    v8[21] += v31;
    *v4 += v31;
    if ( (__int64 *)qword_140004000 == &qword_140004000 && *(_WORD *)(qword_140004008 + 72) )
      nullsub_1(*(_QWORD *)(qword_140004008 + 64), v31, v25, v26);
  }
  while ( v8[21] )
  {
    v32 = sub_1400010DB(v8);
    v33 = v32;
    if ( !v32 )
      break;
    *(_DWORD *)(v32 + 48) = sub_140001001(v8, v32);
    v34 = v41;
    v35 = (__int64 ***)(v33 + 168);
    if ( *v41 != (__int64 *)&v40 )
      goto LABEL_50;
    *(_QWORD *)(v33 + 176) = v41;
    *v35 = &v40;
    *v34 = v35;
    v41 = (__int64 **)(v33 + 168);
  }
  qword_140004078(v8 + 36);
  while ( 1 )
  {
    v37 = v40;
    result = &v40;
    if ( v40 == (__int64 *)&v40 )
      break;
    if ( (__int64 **)v40[1] != &v40 )
      goto LABEL_50;
    v39 = (__int64 *)*v40;
    if ( *(__int64 **)(*v40 + 8) != v40 )
      goto LABEL_50;
    v40 = (__int64 *)*v40;
    v39[1] = (__int64)&v40;
    LOBYTE(v36) = 6;
    qword_140004070(v37 - 21, v36);
    qword_140004068(v8 + 8, v37 - 21, 32);
  }
  if ( (__int64 *)qword_140004000 == &qword_140004000 && *(_WORD *)(qword_140004008 + 72) )
  {
    LOBYTE(v36) = 5;
    return (__int64 **)nullsub_1(*(_QWORD *)(qword_140004008 + 64), v36, 3, 60);
  }
  return result;
}
// 140004080: invalid function type '?' has been ignored
// 140004078: invalid function type '?' has been ignored
// 140004070: invalid function type '?' has been ignored
// 140004068: invalid function type '?' has been ignored
// 140001285: variable 'v16' is possibly undefined
// 140001285: variable 'v14' is possibly undefined
// 14000130B: variable 'v11' is possibly undefined
// 14000130B: variable 'v13' is possibly undefined
// 140001485: variable 'v26' is possibly undefined
// 1400014FA: variable 'v25' is possibly undefined
// 140001594: variable 'v36' is possibly undefined
// 140001000: using guessed type __int64 __fastcall nullsub_1(_QWORD, _QWORD, _QWORD, _QWORD);
// 140001001: using guessed type __int64 __fastcall sub_140001001(_QWORD, _QWORD);
// 1400010DB: using guessed type __int64 __fastcall sub_1400010DB(_QWORD);
// 140002780: using guessed type __int64 __fastcall sub_140002780(_QWORD, _QWORD, _QWORD, _QWORD);
// 140004000: using guessed type __int64 qword_140004000;
// 140004008: using guessed type __int64 qword_140004008;
// 140004068: using guessed type __int64 (__fastcall *qword_140004068)(_QWORD, _QWORD, _QWORD);
// 140004070: using guessed type __int64 (__fastcall *qword_140004070)(_QWORD, _QWORD);
// 140004078: using guessed type __int64 (__fastcall *qword_140004078)(_QWORD);
// 140004080: using guessed type __int64 (__fastcall *qword_140004080)(_QWORD);

//----- (000000014000160C) ----------------------------------------------------
__int64 __fastcall sub_14000160C(__int64 ***a1)
{
  __int64 v2; // r9
  __int64 **i; // rdx
  __int64 *v4; // r8
  __int64 *v5; // rcx

  v2 = GetKernelBaseAddress(0);
  if ( !v2 )
    return 3221226021LL;
  for ( i = *a1; i != (__int64 **)a1; i = (__int64 **)*i )
  {
    v4 = i[6];
    if ( (__int64 *)v2 == v4 )
    {
      v5 = i[1];
      if ( v5 >= v4 && v5 < (__int64 *)((char *)v4 + *((unsigned int *)i + 16)) )
      {
        qword_140004028 = (__int64)i[1];
        break;
      }
    }
  }
  if ( qword_140004028 )
    return 0;
  else
    return 3221226021LL;
}
// 140001820: using guessed type __int64 __fastcall sub_140001820(_QWORD);
// 140004028: using guessed type __int64 qword_140004028;

//----- (0000000140001670) ----------------------------------------------------
void __fastcall sub_140001670(__int64 a1)
{
  struct _ERESOURCE *v2; // rcx
  int v3; // r8d
  __int64 v4; // r9
  __int64 *v5; // rdx

  if ( P )
  {
    v2 = (struct _ERESOURCE *)*((_QWORD *)P + 114);
    if ( v2 )
    {
      if ( *((_QWORD *)P + 115) )
      {
        ExAcquireResourceExclusiveLite(v2, 1u);
        v3 = 0;
        v4 = *(_QWORD *)(*((_QWORD *)P + 115) + 16LL);
        v5 = *(__int64 **)(v4 + 32);
        *(_OWORD *)(v4 + 48) = *(_OWORD *)(a1 + 88);
        *(_DWORD *)(v4 + 64) = *(_DWORD *)(a1 + 156);
        while ( v5 != *(__int64 **)(v4 + 40) )
        {
          if ( v5 )
          {
            if ( *((_DWORD *)v5 + 8) == *(_DWORD *)(a1 + 156) )
            {
              *((_OWORD *)v5 + 1) = *(_OWORD *)(a1 + 88);
              *((_DWORD *)v5 + 8) = v3 + *(_DWORD *)(a1 + 156);
              byte_140004051 = 1;
            }
          }
          v5 = (__int64 *)*v5;
          ++v3;
        }
        ExReleaseResourceLite(*((PERESOURCE *)P + 114));
      }
    }
  }
}
// 140004051: using guessed type char byte_140004051;

//----- (0000000140001730) ----------------------------------------------------
char __fastcall sub_140001730(__int64 a1, unsigned __int64 a2)
{
  __int64 v3; // rax
  __int64 v4; // rdx
  unsigned __int64 v5; // r10
  __int64 *v6; // rdx
  __int64 *v7; // r11
  __int64 *v8; // r10
  unsigned __int64 v9; // rcx

  if ( byte_140004051 )
  {
    v3 = *(_QWORD *)(a1 + 40);
    if ( v3 )
    {
      v4 = *(_QWORD *)(v3 + 8);
      if ( v4 )
      {
        v5 = *(_QWORD *)(v4 + 48);
        if ( a2 >= v5 && a2 < v5 + *(unsigned int *)(v3 + 64) )
          *(_DWORD *)(v4 + 88) = 0;
      }
      v6 = *(__int64 **)(a1 + 40);
      v7 = v6;
      do
      {
        v8 = (__int64 *)*v6;
        if ( (__int64 *)*v6 == v7 )
          break;
        if ( v6[7] > MmUserProbeAddress )
        {
          v9 = v6[6];
          if ( a2 >= v9 && a2 < v9 + *((unsigned int *)v6 + 16) )
          {
            *((_DWORD *)v6 + 22) = 0;
            return 1;
          }
          v8 = (__int64 *)*v6;
        }
        v6 = v8;
      }
      while ( v8 );
    }
  }
  return 0;
}
// 140004051: using guessed type char byte_140004051;

//----- (00000001400017F8) ----------------------------------------------------
__int64 DisableObRegCallbacks()
{
  if ( RegistrationHandle )
  {
    ObUnRegisterCallbacks(RegistrationHandle);
    RegistrationHandle = 0;
  }
  return 0;
}

//----- (0000000140001820) ----------------------------------------------------
__int64 __fastcall GetKernelBaseAddress(int *a1)
{
  const wchar_t *v2; // rax
  __int64 v3; // rcx
  __int16 v4; // cx
  PVOID SystemRoutineAddress; // rsi
  __m128 *Pool2; // rbx
  unsigned __int32 v7; // edx
  __m128 *v8; // rcx
  unsigned __int64 v9; // r8
  __int64 v10; // rcx
  int v11; // eax
  struct _UNICODE_STRING SystemRoutineName; // [rsp+20h] [rbp-10h] BYREF
  ULONG ReturnLength; // [rsp+58h] [rbp+28h] BYREF

  ReturnLength = 0;
  if ( qword_140004040 )
  {
    if ( a1 )
      *a1 = dword_140004034;
    return qword_140004040;
  }
  SystemRoutineName = 0;
  v2 = L"NtOpenFile";
  v3 = 0x7FFF;
  while ( *v2 )
  {
    ++v2;
    if ( !--v3 )
      goto LABEL_9;
  }
  v4 = 2 * v3;
  SystemRoutineName.Buffer = L"NtOpenFile";
  SystemRoutineName.Length = -2 - v4;
  SystemRoutineName.MaximumLength = -v4;
LABEL_9:
  SystemRoutineAddress = MmGetSystemRoutineAddress(&SystemRoutineName);
  if ( SystemRoutineAddress )
  {
    ZwQuerySystemInformation(SystemModuleInformation, 0, ReturnLength, &ReturnLength);
    if ( ReturnLength )
    {
      Pool2 = (__m128 *)ExAllocatePool2(64, ReturnLength, 1195860300);
      sub_140002A40(Pool2, 0, ReturnLength);
      if ( ZwQuerySystemInformation(SystemModuleInformation, Pool2, ReturnLength, &ReturnLength) >= 0 )
      {
        v7 = 0;
        if ( Pool2->m128_i32[0] )
        {
          v8 = Pool2 + 2;
          while ( 1 )
          {
            v9 = v8[-1].m128_u64[1];
            if ( (unsigned __int64)SystemRoutineAddress >= v9
              && (unsigned __int64)SystemRoutineAddress < v9 + v8->m128_u32[0] )
            {
              break;
            }
            ++v7;
            v8 = (__m128 *)((char *)v8 + 296);
            if ( v7 >= Pool2->m128_i32[0] )
              goto LABEL_20;
          }
          v10 = 74LL * v7;
          qword_140004040 = Pool2[1].m128_i64[(unsigned __int64)v10 / 2 + 1];
          v11 = Pool2[2].m128_i32[v10];
          dword_140004034 = v11;
          if ( a1 )
            *a1 = v11;
        }
      }
LABEL_20:
      if ( Pool2 )
        ExFreePoolWithTag(Pool2, 0x4747614Cu);
      return qword_140004040;
    }
  }
  return 0;
}
// 140002B90: using guessed type wchar_t aNtopenfile[11];
// 140003050: using guessed type __int64 __fastcall ExAllocatePool2(_QWORD, _QWORD, _QWORD);
// 140004034: using guessed type int dword_140004034;
// 140004040: using guessed type __int64 qword_140004040;

//----- (00000001400019A0) ----------------------------------------------------
// Finding the driver for mouse movements if im not wrong
__int64 __fastcall FindMouseDriverChain(_QWORD *a1)
{
  __int64 result; // rax
  int v3; // edi
  _QWORD *v4; // r8
  _QWORD *i; // rcx
  __int64 j; // rax
  __int64 v7; // rdi
  __int64 v8; // rdx
  unsigned __int64 v9; // r9
  unsigned __int64 v10; // r10
  __int64 v11; // rax
  char v12; // [rsp+28h] [rbp-38h]
  int v13; // [rsp+28h] [rbp-38h]
  struct _UNICODE_STRING DestinationString; // [rsp+40h] [rbp-20h] BYREF
  struct _UNICODE_STRING v15; // [rsp+50h] [rbp-10h] BYREF
  PVOID Object; // [rsp+88h] [rbp+28h] BYREF
  PVOID v17; // [rsp+90h] [rbp+30h] BYREF

  RtlInitUnicodeString(&DestinationString, L"\\Driver\\MouClass");
  Object = 0;
  v12 = 0;
  result = ObReferenceObjectByName(&DestinationString, 64, 0, 0, IoDriverObjectType, v12, 0, &Object);
  if ( (int)result >= 0 )
  {
    RtlInitUnicodeString(&v15, L"\\Driver\\MouHID");
    v17 = 0;
    LOBYTE(v13) = 0;
    v3 = ObReferenceObjectByName(&v15, 64, 0, 0, IoDriverObjectType, v13, 0, &v17);
    if ( v3 >= 0 )
    {
      v4 = Object;
      for ( i = (_QWORD *)*((_QWORD *)v17 + 1); i && !a1[1]; i = (_QWORD *)i[3] )
      {
        for ( j = v4[1]; j && !a1[1]; j = *(_QWORD *)(j + 16) )
        {
          if ( !*(_QWORD *)(j + 16) && !*a1 )
            *a1 = j;
          v7 = i[8];
          v8 = 0;
          v9 = (unsigned __int64)(i[39] - v7) >> 2;
          if ( v9 )
          {
            while ( 1 )
            {
              if ( *(_QWORD *)(v7 + 8 * v8) == j )
              {
                v10 = *(_QWORD *)(v7 + 8 * v8 + 8);
                if ( v10 > (unsigned __int64)v4 )
                  break;
              }
              if ( ++v8 >= v9 )
                goto LABEL_19;
            }
            a1[1] = v10;
          }
LABEL_19:
          ;
        }
      }
      if ( !*a1 )
      {
        v11 = v4[1];
        if ( v11 )
        {
          while ( *(_QWORD *)(v11 + 16) )
            v11 = *(_QWORD *)(v11 + 16);
          *a1 = v11;
        }
      }
      ObfDereferenceObject(v4);
      ObfDereferenceObject(v17);
      if ( *a1 && a1[1] )
        return 0;
      else
        return 3221226021LL;
    }
    else
    {
      if ( Object )
        ObfDereferenceObject(Object);
      return (unsigned int)v3;
    }
  }
  return result;
}
// 140001A4B: variable 'v13' is possibly undefined
// 140003130: using guessed type __int64 __fastcall ObReferenceObjectByName(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD, _QWORD);

//----- (0000000140001B3C) ----------------------------------------------------
void __fastcall sub_140001B3C(__int128 *a1, int a2, unsigned int a3, __int16 a4)
{
  __int128 v4; // xmm6
  KIRQL v5; // bl
  _BYTE v6[8]; // [rsp+20h] [rbp-48h] BYREF
  __int128 v7; // [rsp+28h] [rbp-40h] BYREF
  __int64 v8; // [rsp+38h] [rbp-30h]
  __int64 v9; // [rsp+40h] [rbp-28h] BYREF

  v4 = *a1;
  v7 = 0;
  HIDWORD(v7) = a2;
  v8 = a3;
  WORD2(v7) = a4;
  v5 = KfRaiseIrql(2u);
  sub_14000112E(v4, &v7, &v9, v6);
  KeLowerIrql(v5);
}
// 14000112E: using guessed type __int64 __fastcall sub_14000112E(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140001BD0) ----------------------------------------------------
__int64 __fastcall ClearFlags(__int64 a1, __int64 a2)
{
  _DWORD *v3; // rax
  int v4; // ecx

  if ( dword_140004030 && dword_140004030 == (unsigned int)PsGetProcessId(*(PEPROCESS *)(a2 + 8)) && *(_DWORD *)a2 == 1 )
  {
    v3 = *(_DWORD **)(a2 + 32);
    v4 = v3[1];
    if ( (v4 & 1) != 0 )
      *v3 &= ~1u;
    if ( (v4 & 8) != 0 )
      **(_DWORD **)(a2 + 32) &= ~8u;
    if ( (v4 & 0x10) != 0 )
      **(_DWORD **)(a2 + 32) &= ~0x10u;
    if ( (v4 & 0x20) != 0 )
      **(_DWORD **)(a2 + 32) &= ~0x20u;
    if ( (v4 & 0x800) != 0 )
      **(_DWORD **)(a2 + 32) &= ~0x800u;
    if ( (v4 & 2) != 0 )
      **(_DWORD **)(a2 + 32) &= ~2u;
  }
  return 0;
}
// 140004030: using guessed type int dword_140004030;

//----- (0000000140001C50) ----------------------------------------------------
__int64 SetupObRegCallbacks()
{
  unsigned int v0; // ebx
  POBJECT_TYPE *v2; // [rsp+20h] [rbp-29h] BYREF
  int v3; // [rsp+28h] [rbp-21h]
  int v4; // [rsp+2Ch] [rbp-1Dh]
  __int64 (__fastcall *v5)(); // [rsp+30h] [rbp-19h]
  __int64 (__fastcall *v6)(); // [rsp+38h] [rbp-11h]
  struct _OB_CALLBACK_REGISTRATION CallbackRegistration; // [rsp+40h] [rbp-9h] BYREF
  __int128 v8; // [rsp+68h] [rbp+1Fh] BYREF
  __int128 v9; // [rsp+78h] [rbp+2Fh]
  __int64 v10; // [rsp+88h] [rbp+3Fh]
  struct _UNICODE_STRING DestinationString; // [rsp+90h] [rbp+47h] BYREF

  v0 = 0;
  if ( RegistrationHandle )
    return 0;
  v4 = 0;
  v10 = 0;
  v8 = 0;
  *(_DWORD *)(&CallbackRegistration.OperationRegistrationCount + 1) = 0;
  LOWORD(v8) = 120;
  v9 = 0;
  WORD4(v9) = 1;
  if ( ObGetFilterVersion() == 256 )
  {
    v2 = PsProcessType;
    v5 = ClearFlags;
    v3 = 1;
    v6 = nullsub_2;
    *(_DWORD *)&CallbackRegistration.Version = 65792;
    RtlInitUnicodeString(&DestinationString, L"XXXXX");
    CallbackRegistration.RegistrationContext = &v8;
    CallbackRegistration.OperationRegistration = (OB_OPERATION_REGISTRATION *)&v2;
    CallbackRegistration.Altitude = DestinationString;
    return (unsigned int)ObRegisterCallbacks(&CallbackRegistration, &RegistrationHandle);
  }
  return v0;
}
// 140001BC0: using guessed type __int64 __fastcall nullsub_2();
// 140001BD0: using guessed type __int64 __fastcall sub_140001BD0();

//----- (0000000140001D24) ----------------------------------------------------
__int64 __fastcall sub_140001D24(__int64 a1, _WORD *a2)
{
  unsigned int v2; // r8d
  __int64 v3; // r10
  _WORD *v4; // rax
  __int16 v5; // r9

  v2 = 0;
  *(_OWORD *)a1 = 0;
  if ( a2 )
  {
    v3 = 0x7FFF;
    v4 = a2;
    do
    {
      if ( !*v4 )
        break;
      ++v4;
      --v3;
    }
    while ( v3 );
    if ( v3 )
    {
      if ( !a1 )
        return (unsigned int)-1073741811;
      v5 = 2 * (0x7FFF - v3);
      *(_QWORD *)(a1 + 8) = a2;
      *(_WORD *)a1 = v5;
      *(_WORD *)(a1 + 2) = v5 + 2;
    }
    return v3 == 0 ? 0xC000000D : 0;
  }
  return v2;
}

//----- (0000000140001DA0) ----------------------------------------------------
#error "140001DA0: function frame is wrong (funcsize=0)"

//----- (00000001400022A0) ----------------------------------------------------
SIZE_T __fastcall ComparePattern(const void *a1, char *a2, SIZE_T a3, char a4)
{
  char *v5; // rdi
  SIZE_T v6; // rbx
  __int64 v7; // r14

  v5 = a2;
  if ( !a4 )
    return RtlCompareMemory(a1, a2, a3);
  v6 = 0;
  if ( a3 )
  {
    v7 = (_BYTE *)a1 - a2;
    do
    {
      if ( sub_140002700(v5[v7], *v5) && sub_140002700(*v5, 63) )
        break;
      ++v6;
      ++v5;
    }
    while ( v6 < a3 );
  }
  return v6;
}

//----- (0000000140002318) ----------------------------------------------------
__int64 __fastcall sub_140002318(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v6; // rbp
  __int64 v7; // rbx
  __int64 Pool2; // rax
  void *v9; // r14
  __int64 v10; // rax
  __int64 v11; // r9
  __int64 v12; // r15
  unsigned __int64 v13; // rdi
  __int64 v14; // rbx
  char v16; // [rsp+68h] [rbp+20h] BYREF

  v6 = 0;
  v16 = 0;
  v7 = sub_1400023FC(a3, 0, 0, &v16);
  if ( v7 != -1 && a2 - v7 - a1 >= 0 )
  {
    Pool2 = ExAllocatePool2(64, v7, 1195860300);
    v9 = (void *)Pool2;
    if ( Pool2 )
    {
      v10 = sub_1400023FC(a3, Pool2, v7, &v16);
      v12 = v10;
      if ( v10 != -1 )
      {
        v13 = a2 - v10 - a1;
        if ( v13 )
        {
          v14 = a1;
          while ( 1 )
          {
            LOBYTE(v11) = v16;
            if ( v12 == ComparePattern(v14, v9, v12, v11) )
              break;
            if ( ++v14 - a1 >= v13 )
              goto LABEL_11;
          }
          v6 = v14;
        }
      }
LABEL_11:
      ExFreePoolWithTag(v9, 0);
    }
  }
  return v6;
}
// 1400023B7: variable 'v11' is possibly undefined
// 1400022A0: using guessed type __int64 __fastcall sub_1400022A0(_QWORD, _QWORD, _QWORD, _QWORD);
// 1400023FC: using guessed type __int64 __fastcall sub_1400023FC(_QWORD, _QWORD, _QWORD, _QWORD);
// 140003050: using guessed type __int64 __fastcall ExAllocatePool2(_QWORD, _QWORD, _QWORD);

//----- (00000001400023FC) ----------------------------------------------------
unsigned __int64 __fastcall sub_1400023FC(char *a1, __int64 a2, unsigned __int64 a3, bool *a4)
{
  unsigned __int64 v4; // rbx
  unsigned __int64 v5; // rbp
  __int64 v8; // rax
  unsigned __int64 v9; // r12
  char *v10; // rdi
  __int64 v11; // rsi
  __m128 *Pool2; // rax
  __m128 *v13; // r14
  __int64 v14; // rcx
  __int16 v15; // ax
  char *v16; // rdi
  bool v17; // al
  char String[2]; // [rsp+20h] [rbp-48h] BYREF
  char v20; // [rsp+22h] [rbp-46h]
  ULONG Value[17]; // [rsp+24h] [rbp-44h] BYREF

  v4 = 0;
  Value[0] = 0;
  v5 = 0;
  *(_WORD *)String = 0;
  v20 = 0;
  v8 = -1;
  do
    ++v8;
  while ( a1[v8] );
  v9 = (unsigned int)v8;
  if ( (_DWORD)v8 )
  {
    v10 = a1;
    v11 = (unsigned int)v8;
    do
    {
      if ( isxdigit(*v10) || !sub_140002700(*v10, 63) )
        ++v5;
      ++v10;
      --v11;
    }
    while ( v11 );
    if ( v5 )
    {
      Pool2 = (__m128 *)ExAllocatePool2(64, v5, 1195860300);
      v13 = Pool2;
      if ( Pool2 )
      {
        sub_140002A40(Pool2, 0, v5);
        do
        {
          if ( isxdigit(a1[v4]) || !sub_140002700(a1[v4], 63) )
          {
            v14 = -1;
            do
              ++v14;
            while ( v13->m128_i8[v14] );
            v15 = *(_WORD *)&a1[v4++];
            *(__int16 *)((char *)v13->m128_i16 + v14) = v15;
          }
          ++v4;
        }
        while ( v4 < v9 );
        if ( (v5 & 1) == 0 )
        {
          v4 = v5 >> 1;
          if ( !a2 )
            goto LABEL_33;
          if ( a3 >= v4 )
          {
            v16 = (char *)v13;
            while ( 1 )
            {
              if ( sub_140002700(*v16, 63) || sub_140002700(v16[1], 63) )
              {
                if ( !isxdigit(*v16)
                  || !isxdigit(v16[1])
                  || (*(_WORD *)String = *(_WORD *)v16, RtlCharToInteger(String, 0x10u, Value) < 0) )
                {
                  v4 = -1;
                  goto LABEL_33;
                }
                *(_BYTE *)(((unsigned __int64)(v16 - (char *)v13) >> 1) + a2) = Value[0];
                v17 = *a4;
              }
              else
              {
                *(_BYTE *)(((unsigned __int64)(v16 - (char *)v13) >> 1) + a2) = 63;
                v17 = 1;
              }
              v16 += 2;
              *a4 = v17;
              if ( v16 - (char *)v13 >= v5 )
                goto LABEL_33;
            }
          }
        }
        v4 = -1;
LABEL_33:
        ExFreePoolWithTag(v13, 0);
      }
    }
  }
  return v4;
}
// 14000251C: conditional instruction was optimized away because rbp.8!=0
// 140003050: using guessed type __int64 __fastcall ExAllocatePool2(_QWORD, _QWORD, _QWORD);

//----- (000000014000266C) ----------------------------------------------------
__int64 __fastcall sub_14000266C(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  int v3; // edx

  result = *(_QWORD *)(a2 + 8);
  v3 = *(unsigned __int8 *)(*(unsigned int *)(*(_QWORD *)(a2 + 16) + 8LL) + result + 3);
  if ( (v3 & 0xF) != 0 )
    return v3 & 0xFFFFFFF0;
  return result;
}

//----- (0000000140002700) ----------------------------------------------------
bool __fastcall sub_140002700(char a1, char a2)
{
  return a1 != a2;
}

//----- (0000000140002710) ----------------------------------------------------
bool __fastcall sub_140002710(__int16 a1, __int16 a2)
{
  return a1 != a2;
}

//----- (0000000140002720) ----------------------------------------------------
bool __fastcall sub_140002720(int a1, int a2)
{
  return a1 != a2;
}

//----- (0000000140002730) ----------------------------------------------------
bool __fastcall sub_140002730(__int64 a1, __int64 a2)
{
  return a1 != a2;
}

//----- (0000000140002780) ----------------------------------------------------
__m128 *__fastcall sub_140002780(char *a1, char *a2, unsigned __int64 a3)
{
  __m128 *result; // rax
  __int64 v4; // r11
  __int64 v5; // rdx
  __int128 v6; // xmm1
  bool v7; // cf
  signed __int64 v8; // rdx
  char v9; // r11
  char *v10; // rcx
  char v11; // r11
  char *v12; // r11
  signed __int64 v13; // rdx
  __m128 v14; // xmm0
  unsigned __int64 v15; // rcx
  unsigned __int64 v16; // rcx
  __m128 v17; // xmm1
  unsigned __int64 v18; // r8
  unsigned __int64 v19; // r9
  __int128 v20; // xmm1
  __int128 v21; // xmm2
  __int128 v22; // xmm3
  __m128 v23; // xmm4
  unsigned __int64 j; // r9
  unsigned __int64 v25; // r8
  unsigned __int64 v26; // r9
  __m128 v27; // xmm1
  __m128 v28; // xmm2
  __m128 v29; // xmm3
  __m128 v30; // xmm4
  char *v31; // rcx
  __int128 v32; // xmm0
  unsigned __int64 v33; // rcx
  unsigned __int64 v34; // r8
  _OWORD *v35; // r11
  __int128 v36; // xmm1
  unsigned __int64 v37; // r9
  __int128 v38; // xmm1
  __int128 v39; // xmm2
  __int128 v40; // xmm3
  __int128 v41; // xmm4
  unsigned __int64 i; // r9
  unsigned __int64 v43; // r8

  result = (__m128 *)a1;
  if ( a3 < 8 )
  {
    if ( a3 )
    {
      v7 = a2 < a1;
      v8 = a2 - a1;
      if ( v7 )
      {
        v10 = &a1[a3];
        do
        {
          v11 = v10[v8 - 1];
          --v10;
          --a3;
          *v10 = v11;
        }
        while ( a3 );
      }
      else
      {
        do
        {
          v9 = a1[v8];
          ++a1;
          --a3;
          *(a1 - 1) = v9;
        }
        while ( a3 );
      }
    }
  }
  else if ( a3 > 0x10 )
  {
    if ( a3 > 0x20 )
    {
      v12 = &a2[a3];
      v7 = a2 < a1;
      v13 = a2 - a1;
      if ( v7 && v12 > a1 )
      {
        v31 = &a1[a3];
        v32 = *(_OWORD *)&v31[v13 - 16];
        v33 = (unsigned __int64)(v31 - 16);
        v34 = a3 - 16;
        if ( (v33 & 0xF) != 0 )
        {
          v35 = (_OWORD *)v33;
          v33 &= 0xFFFFFFFFFFFFFFF0uLL;
          v36 = *(_OWORD *)(v33 + v13);
          *v35 = v32;
          v32 = v36;
          v34 = v33 - (_QWORD)result;
        }
        v37 = v34 >> 6;
        if ( v34 >> 6 )
        {
          v34 &= 0x3Fu;
          do
          {
            v38 = *(_OWORD *)(v33 + v13 - 16);
            v39 = *(_OWORD *)(v33 + v13 - 32);
            v40 = *(_OWORD *)(v33 + v13 - 48);
            v41 = *(_OWORD *)(v33 + v13 - 64);
            *(_OWORD *)v33 = v32;
            v33 -= 64LL;
            --v37;
            *(_OWORD *)(v33 + 48) = v38;
            *(_OWORD *)(v33 + 32) = v39;
            *(_OWORD *)(v33 + 16) = v40;
            v32 = v41;
          }
          while ( v37 );
        }
        for ( i = v34 >> 4; i; --i )
        {
          *(_OWORD *)v33 = v32;
          v32 = *(_OWORD *)(v33 + v13 - 16);
          v33 -= 16LL;
        }
        v43 = v34 & 0xF;
        if ( v43 )
          *(_OWORD *)(v33 - v43) = *(_OWORD *)(v33 - v43 + v13);
        *(_OWORD *)v33 = v32;
      }
      else
      {
        v14 = *(__m128 *)&a1[v13];
        v15 = (unsigned __int64)(a1 + 16);
        if ( (v15 & 0xF) != 0 )
        {
          v16 = v15 & 0xFFFFFFFFFFFFFFF0uLL;
          v17 = *(__m128 *)(v16 + v13);
          *result = v14;
          v14 = v17;
          v15 = v16 + 16;
        }
        v18 = (unsigned __int64)result + a3 - v15;
        v19 = v18 >> 6;
        if ( v18 >> 6 )
        {
          if ( v19 > 0x1000 )
          {
            v26 = v18 >> 6;
            v18 &= 0x3Fu;
            _mm_prefetch((const char *)(v15 + v13 + 64), 0);
            do
            {
              v27 = *(__m128 *)(v15 + v13);
              v28 = *(__m128 *)(v15 + v13 + 16);
              v29 = *(__m128 *)(v15 + v13 + 32);
              v30 = *(__m128 *)(v15 + v13 + 48);
              _mm_stream_ps((float *)(v15 - 16), v14);
              v15 += 64LL;
              _mm_prefetch((const char *)(v15 + v13 + 64), 0);
              --v26;
              _mm_stream_ps((float *)(v15 - 64), v27);
              _mm_stream_ps((float *)(v15 - 48), v28);
              _mm_stream_ps((float *)(v15 - 32), v29);
              v14 = v30;
            }
            while ( v26 );
            _mm_sfence();
          }
          else
          {
            v18 &= 0x3Fu;
            do
            {
              v20 = *(_OWORD *)(v15 + v13);
              v21 = *(_OWORD *)(v15 + v13 + 16);
              v22 = *(_OWORD *)(v15 + v13 + 32);
              v23 = *(__m128 *)(v15 + v13 + 48);
              *(__m128 *)(v15 - 16) = v14;
              v15 += 64LL;
              --v19;
              *(_OWORD *)(v15 - 64) = v20;
              *(_OWORD *)(v15 - 48) = v21;
              *(_OWORD *)(v15 - 32) = v22;
              v14 = v23;
            }
            while ( v19 );
          }
        }
        for ( j = v18 >> 4; j; --j )
        {
          *(__m128 *)(v15 - 16) = v14;
          v14 = *(__m128 *)(v15 + v13);
          v15 += 16LL;
        }
        v25 = v18 & 0xF;
        if ( v25 )
          *(_OWORD *)(v15 + v25 - 16) = *(_OWORD *)(v15 + v25 - 16 + v13);
        *(__m128 *)(v15 - 16) = v14;
      }
    }
    else
    {
      v6 = *(_OWORD *)&a2[a3 - 16];
      *(_OWORD *)a1 = *(_OWORD *)a2;
      *(_OWORD *)&a1[a3 - 16] = v6;
    }
  }
  else
  {
    v4 = *(_QWORD *)a2;
    v5 = *(_QWORD *)&a2[a3 - 8];
    *(_QWORD *)a1 = v4;
    *(_QWORD *)&a1[a3 - 8] = v5;
  }
  return result;
}

//----- (0000000140002A40) ----------------------------------------------------
__m128 *__fastcall sub_140002A40(__m128 *a1, unsigned __int8 a2, unsigned __int64 a3)
{
  __m128 *result; // rax
  __int64 v4; // rdx
  unsigned __int64 v5; // r9
  char *v6; // rcx
  unsigned __int64 v7; // r8
  __m128 v8; // xmm0
  char *v9; // r8
  __m128 *v10; // rcx
  unsigned __int64 v11; // r8
  unsigned __int64 v12; // r9
  unsigned __int64 i; // r9
  __int64 v14; // r8

  result = a1;
  if ( a3 < 8 )
  {
    for ( ; a3; --a3 )
      a1->m128_i8[a3 - 1] = a2;
  }
  else
  {
    v4 = 0x101010101010101LL * a2;
    if ( a3 >= 0x4F )
    {
      v8 = _mm_movelh_ps((__m128)(unsigned __int64)v4, (__m128)(unsigned __int64)v4);
      *a1 = v8;
      v9 = (char *)a1 + a3;
      v10 = (__m128 *)((unsigned __int64)&a1[1] & 0xFFFFFFFFFFFFFFF0uLL);
      v11 = v9 - (char *)v10;
      v12 = v11 >> 7;
      if ( v11 >> 7 )
      {
        do
        {
          *v10 = v8;
          v10[1] = v8;
          v10 += 8;
          v10[-6] = v8;
          v10[-5] = v8;
          --v12;
          v10[-4] = v8;
          v10[-3] = v8;
          v10[-2] = v8;
          v10[-1] = v8;
        }
        while ( v12 );
        v11 &= 0x7Fu;
      }
      for ( i = v11 >> 4; i; --i )
        *v10++ = v8;
      v14 = v11 & 0xF;
      if ( v14 )
        *(__m128 *)((char *)v10 + v14 - 16) = v8;
    }
    else
    {
      v5 = a3 & 0x78;
      v6 = (char *)a1 + (a3 & 0xFFFFFFFFFFFFFFF8uLL);
      do
      {
        *(unsigned __int64 *)((char *)&result->m128_u64[-1] + v5) = v4;
        v5 -= 8LL;
      }
      while ( v5 );
      v7 = a3 & 7;
      if ( v7 )
        *(_QWORD *)&v6[v7 - 8] = v4;
    }
  }
  return result;
}
// 140002A63: mask 0xFFFFFFFFFFFFFFF8 is shortened because r8.8 <= 0x4E
// 140002A90: masking with 0x7 was optimized away because r8.8 <= 0x7

//----- (0000000140006000) ----------------------------------------------------
__int64 __fastcall IoControlHandler(__int64 a1, IRP *a2)
{
  struct _IO_STACK_LOCATION *CurrentStackLocation; // rax
  int v3; // esi
  struct _IRP *MasterIrp; // rbx
  unsigned int Options; // ecx
  DWORD LowPart; // eax
  __int64 MdlAddress_low; // r9
  __int64 v9; // r8
  __int64 v10; // rdx
  int v11; // eax
  NTSTATUS v12; // eax
  __int128 v13; // xmm0
  unsigned int Status; // ebx
  __int128 v16; // [rsp+20h] [rbp-18h] BYREF

  CurrentStackLocation = a2->Tail.Overlay.CurrentStackLocation;
  v3 = 0;
  MasterIrp = a2->AssociatedIrp.MasterIrp;
  a2->IoStatus.Status = 0;
  a2->IoStatus.Information = 0;
  Options = CurrentStackLocation->Parameters.Create.Options;
  if ( CurrentStackLocation->MajorFunction != 14 )
    goto LABEL_39;
  LowPart = CurrentStackLocation->Parameters.Read.ByteOffset.LowPart;
  switch ( LowPart )
  {
    case 0x95060D00:
      break;
    case 0x9506CD04:
      if ( Options >= 0x18 && MasterIrp )
      {
        // Writing mem to target proc
        v11 = WriteMemory(MasterIrp);
        goto LABEL_37;
      }
LABEL_38:
      a2->IoStatus.Status = -1073741820;
      break;
    case 0x9506CD08:
      if ( Options >= 0x18 && MasterIrp )
      {
        v11 = ReadMemory(MasterIrp);
        goto LABEL_37;
      }
      goto LABEL_21;
    case 0x9506CD0C:
      if ( Options >= 0x40 && MasterIrp )
      {
        v16 = 0;
        v12 = QueryProcessNamedEntry(MasterIrp, &v16);
        v13 = v16;
        a2->IoStatus.Status = v12;
        *(_OWORD *)&MasterIrp->Type = v13;
        a2->IoStatus.Information = 16;
        break;
      }
      goto LABEL_38;
    case 0x9506CD10:
      if ( Options >= 4 && MasterIrp )
      {
        v11 = GetPid(MasterIrp);
        goto LABEL_37;
      }
      goto LABEL_21;
    case 0x9506CD1C:
      if ( Options >= 4 && MasterIrp )
      {
        dword_140004030 = *(_DWORD *)&MasterIrp->Type;
        v11 = SetupObRegCallbacks();
        goto LABEL_37;
      }
      goto LABEL_21;
    case 0x9506CD20:
      if ( Options >= 4 && MasterIrp )
      {
        v11 = DisableObRegCallbacks();
LABEL_37:
        a2->IoStatus.Status = v11;
        break;
      }
LABEL_21:
      v11 = -1073741820;
      goto LABEL_37;
    case 0x9506CD24:
      if ( Options >= 0xC && MasterIrp )
      {
        if ( byte_140004050 == 1 )
        {
          MdlAddress_low = LOWORD(MasterIrp->MdlAddress);
          v9 = *(unsigned int *)(&MasterIrp->Size + 1);
          v10 = *(unsigned int *)&MasterIrp->Type;
          v16 = xmmword_140004058;
          ((void (__fastcall *)(__int128 *, __int64, __int64, __int64))sub_140001B3C)(&v16, v10, v9, MdlAddress_low);
        }
        else
        {
          v3 = -1073741637;
        }
      }
      else
      {
        v3 = -1073741820;
      }
      a2->IoStatus.Status = v3;
      break;
    default:
      a2->IoStatus.Status = -1073741811;
      break;
  }
LABEL_39:
  Status = a2->IoStatus.Status;
  IofCompleteRequest(a2, 0);
  return Status;
}
// 1400017F8: using guessed type __int64 sub_1400017F8(void);
// 140001B3C: using guessed type __int64 __fastcall sub_140001B3C(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 140001C50: using guessed type __int64 sub_140001C50(void);
// 140004030: using guessed type int dword_140004030;
// 140004050: using guessed type char byte_140004050;
// 140004058: using guessed type __int128 xmmword_140004058;
// 14000635C: using guessed type __int64 __fastcall sub_14000635C(_QWORD, _QWORD);
// 140006450: using guessed type __int64 __fastcall sub_140006450(_QWORD);
// 140006478: using guessed type __int64 __fastcall sub_140006478(_QWORD);
// 140006590: using guessed type __int64 __fastcall sub_140006590(_QWORD);

//----- (00000001400061B0) ----------------------------------------------------
// Get module info from procces
__int64 __fastcall GetProcessModuleInfo(__int64 a1, char a2, const WCHAR *a3, _QWORD *a4)
{
  __int64 ProcessWow64Process; // rsi
  int v8; // ebx
  unsigned int *i; // rbx
  __int64 ProcessPeb; // rsi
  int j; // ebx
  __int64 v12; // rax
  __int64 *k; // rbx
  struct _UNICODE_STRING DestinationString; // [rsp+28h] [rbp-30h] BYREF
  UNICODE_STRING String1; // [rsp+38h] [rbp-20h] BYREF
  union _LARGE_INTEGER Interval; // [rsp+78h] [rbp+20h] BYREF

  if ( !a4 || !a1 )
    return 3221226021LL;
  Interval.QuadPart = -2500000;
  if ( a2 )
  {
    ProcessWow64Process = PsGetProcessWow64Process(a1);
    if ( ProcessWow64Process )
    {
      v8 = 0;
      while ( !*(_DWORD *)(ProcessWow64Process + 12) )
      {
        if ( v8 >= 10 )
          return 3221226021LL;
        KeDelayExecutionThread(0, 1u, &Interval);
        ++v8;
      }
      for ( i = (unsigned int *)*(unsigned int *)(*(unsigned int *)(ProcessWow64Process + 12) + 0xCLL);
            i != (unsigned int *)(*(unsigned int *)(ProcessWow64Process + 12) + 12LL);
            i = (unsigned int *)*i )
      {
        sub_140001D24(&String1, i[12]);
        RtlInitUnicodeString(&DestinationString, a3);
        if ( !RtlCompareUnicodeString(&String1, &DestinationString, 1u) )
        {
          *a4 = i[6];
          a4[1] = i[8];
          return 0;
        }
      }
      return 0;
    }
    else
    {
      return 3221226021LL;
    }
  }
  else
  {
    ProcessPeb = PsGetProcessPeb();
    if ( ProcessPeb )
    {
      for ( j = 0; ; ++j )
      {
        v12 = *(_QWORD *)(ProcessPeb + 24);
        if ( v12 )
          break;
        if ( j >= 10 )
          return 3221226021LL;
        KeDelayExecutionThread(0, 1u, &Interval);
      }
      for ( k = *(__int64 **)(v12 + 16); k != (__int64 *)(*(_QWORD *)(ProcessPeb + 24) + 16LL); k = (__int64 *)*k )
      {
        sub_140001D24(&DestinationString, k[12]);
        RtlInitUnicodeString(&String1, a3);
        if ( !RtlCompareUnicodeString(&DestinationString, &String1, 1u) )
        {
          *a4 = k[6];
          a4[1] = *((unsigned int *)k + 16);
          return 0;
        }
      }
      return 0;
    }
    else
    {
      return 3221226021LL;
    }
  }
}
// 140006231: conditional instruction was optimized away because eax.4==0
// 1400062DB: conditional instruction was optimized away because rax.8==0
// 140001D24: using guessed type __int64 __fastcall sub_140001D24(_QWORD, _QWORD);
// 140003108: using guessed type __int64 PsGetProcessPeb(void);
// 140003110: using guessed type __int64 __fastcall PsGetProcessWow64Process(_QWORD);

//----- (000000014000635C) ----------------------------------------------------
__int64 __fastcall sub_14000635C(__int64 a1, __int64 a2)
{
  int v3; // ebx
  __int64 result; // rax
  __int64 v6; // rdx
  union _LARGE_INTEGER v7; // [rsp+30h] [rbp-48h] BYREF
  struct _KAPC_STATE ApcState; // [rsp+38h] [rbp-40h] BYREF

  v3 = 0;
  if ( !Object )
    return (unsigned int)v3;
  v7.QuadPart = 0;
  if ( !KeWaitForSingleObject(Object, Executive, 0, 0, &v7) )
    return 3221225738LL;
  KeStackAttachProcess((PRKPROCESS)Object, &ApcState);
  LOBYTE(v6) = PsGetProcessWow64Process(Object) != 0;
  v3 = GetProcessModuleInfo(Object, v6, a1, a2);
  KeUnstackDetachProcess(&ApcState);
  result = 3221226021LL;
  if ( v3 >= 0 )
    return (unsigned int)v3;
  return result;
}
// 1400063E6: variable 'v6' is possibly undefined
// 140003110: using guessed type __int64 __fastcall PsGetProcessWow64Process(_QWORD);
// 1400061B0: using guessed type __int64 __fastcall sub_1400061B0(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140006430) ----------------------------------------------------
__int64 __fastcall sub_140006430(__int64 a1, IRP *a2)
{
  IofCompleteRequest(a2, 0);
  return (unsigned int)a2->IoStatus.Status;
}

//----- (0000000140006450) ----------------------------------------------------
// Gets process identifier (id or pid)
NTSTATUS __fastcall GetPid(unsigned int *a1)
{
  return PsLookupProcessByProcessId((HANDLE)*a1, (PEPROCESS *)&Object);
}

//----- (0000000140006478) ----------------------------------------------------
// Reading memory from kernel
__int64 __fastcall ReadMemory(_QWORD *a1)
{
  unsigned int v2; // ebx
  PEPROCESS CurrentProcess; // rax
  char v5; // [rsp+28h] [rbp-30h]
  __int64 v6; // [rsp+68h] [rbp+10h] BYREF

  v2 = 0;
  if ( Object )
  {
    v6 = 0;
    CurrentProcess = IoGetCurrentProcess();
    v5 = 0;
    return (unsigned int)MmCopyVirtualMemory(Object, a1[1], CurrentProcess, *a1, a1[2], v5, &v6);
  }
  return v2;
}
// 140003100: using guessed type __int64 __fastcall MmCopyVirtualMemory(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD);

//----- (00000001400064F0) ----------------------------------------------------
void __fastcall UnloadDriver(__int64 a1)
{
  const wchar_t *v2; // rax
  __int64 v3; // rdx
  __int16 v4; // dx
  struct _UNICODE_STRING SymbolicLinkName; // [rsp+20h] [rbp-18h] BYREF

  if ( Object )
    ObfDereferenceObject(Object);
  DisableObRegCallbacks();
  SymbolicLinkName = 0;
  v2 = L"\\DosDevices\\usbprint_f";
  v3 = 0x7FFF;
  while ( *v2 )
  {
    ++v2;
    if ( !--v3 )
      goto LABEL_8;
  }
  v4 = 2 * v3;
  SymbolicLinkName.Buffer = L"\\DosDevices\\usbprint_f";
  SymbolicLinkName.Length = -2 - v4;
  SymbolicLinkName.MaximumLength = -v4;
LABEL_8:
  IoDeleteSymbolicLink(&SymbolicLinkName);
  IoDeleteDevice(*(PDEVICE_OBJECT *)(a1 + 8));
  ExFreePoolWithTag(P, 0);
}
// 140006600: using guessed type wchar_t aDosdevicesUsbp_0[23];

//----- (0000000140006590) ----------------------------------------------------
// Writing memory from kernel
__int64 __fastcall WriteMemory(_QWORD *a1)
{
  unsigned int v2; // ebx
  PEPROCESS CurrentProcess; // rax
  char v5; // [rsp+28h] [rbp-30h]
  __int64 v6; // [rsp+68h] [rbp+10h] BYREF

  v2 = 0;
  if ( Object )
  {
    v6 = 0;
    CurrentProcess = IoGetCurrentProcess();
    v5 = 0;
    return (unsigned int)MmCopyVirtualMemory(CurrentProcess, *a1, Object, a1[1], a1[2], v5, &v6);
  }
  return v2;
}
// 140003100: using guessed type __int64 __fastcall MmCopyVirtualMemory(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD);

//----- (0000000140007000) ----------------------------------------------------
NTSTATUS __fastcall Initializedrv(PDRIVER_OBJECT DriverObject)
{
  __int64 ***DriverSection; // r14
  NTSTATUS result; // eax
  void *Pool2; // rax
  __int64 v5; // rdi
  const wchar_t *v6; // rax
  __int64 v7; // rcx
  __int16 v8; // cx
  const wchar_t *v9; // rax
  __int16 v10; // di
  struct _UNICODE_STRING DeviceName; // [rsp+40h] [rbp-20h] BYREF
  struct _UNICODE_STRING SymbolicLinkName; // [rsp+50h] [rbp-10h] BYREF
  PDEVICE_OBJECT DeviceObject; // [rsp+90h] [rbp+30h] BYREF

  qword_140004080 = (__int64)KeAcquireSpinLockAtDpcLevel;
  qword_140004078 = (__int64)KeReleaseSpinLockFromDpcLevel;
  qword_140004070 = (__int64)IofCompleteRequest;
  qword_140004068 = (__int64)IoReleaseRemoveLockEx;
  DriverSection = (__int64 ***)DriverObject->DriverSection;
  DeviceObject = 0;
  result = sub_14000160C(DriverSection);
  if ( result >= 0 )
  {
    Pool2 = (void *)ExAllocatePool2(64, 928, 1195860300);
    P = Pool2;
    if ( Pool2 )
    {
      sub_140002A40(Pool2, 0, 928);
      PsGetVersion(0, 0, (PULONG)P + 226, 0);
      sub_140001DA0(P);
    }
    v5 = 0x7FFF;
    v6 = L"\\Device\\usbprint_f";
    DeviceName = 0;
    v7 = 0x7FFF;
    while ( *v6 )
    {
      ++v6;
      if ( !--v7 )
        goto LABEL_9;
    }
    v8 = 2 * v7;
    DeviceName.Buffer = L"\\Device\\usbprint_f";
    DeviceName.Length = -2 - v8;
    DeviceName.MaximumLength = -v8;
LABEL_9:
    result = IoCreateDevice(DriverObject, 0, &DeviceName, 0x9506u, 0, 0, &DeviceObject);
    if ( result >= 0 )
    {
      byte_140004050 = (unsigned int)FindMouseDriver(&xmmword_140004058) == 0;
      DriverObject->MajorFunction[0] = (PDRIVER_DISPATCH)&sub_140006430;
      DriverObject->MajorFunction[2] = (PDRIVER_DISPATCH)&sub_140006430;
      DriverObject->MajorFunction[3] = (PDRIVER_DISPATCH)&sub_140006430;
      DriverObject->MajorFunction[4] = (PDRIVER_DISPATCH)&sub_140006430;
      DriverObject->MajorFunction[14] = (PDRIVER_DISPATCH)&IoControlHandler;
      sub_140001670((__int64)DriverSection);
      sub_140001730((__int64)DriverObject, (unsigned __int64)UnloadDriver);
      DriverObject->DriverUnload = (PDRIVER_UNLOAD)UnloadDriver;
      SymbolicLinkName = 0;
      v9 = L"\\DosDevices\\usbprint_f";
      while ( *v9 )
      {
        ++v9;
        if ( !--v5 )
          goto LABEL_15;
      }
      v10 = 2 * v5;
      SymbolicLinkName.Buffer = L"\\DosDevices\\usbprint_f";
      SymbolicLinkName.Length = -2 - v10;
      SymbolicLinkName.MaximumLength = -v10;
LABEL_15:
      if ( IoCreateSymbolicLink(&SymbolicLinkName, &DeviceName) < 0 )
        IoDeleteDevice(DeviceObject);
      return 0;
    }
  }
  return result;
}
// 140001DA0: using guessed type __int64 __fastcall sub_140001DA0(_QWORD);
// 140002A40: using guessed type __int64 __fastcall sub_140002A40(_QWORD, _QWORD, _QWORD);
// 140003050: using guessed type __int64 __fastcall ExAllocatePool2(_QWORD, _QWORD, _QWORD);
// 140004050: using guessed type char byte_140004050;
// 140004058: using guessed type __int128 xmmword_140004058;
// 140004068: using guessed type __int64 qword_140004068;
// 140004070: using guessed type __int64 qword_140004070;
// 140004078: using guessed type __int64 qword_140004078;
// 140004080: using guessed type __int64 qword_140004080;
// 1400064F0: using guessed type __int64 __fastcall sub_1400064F0();
// 140007280: using guessed type wchar_t aDeviceUsbprint[19];
// 1400072B0: using guessed type wchar_t aDosdevicesUsbp[23];

//----- (0000000140007220) ----------------------------------------------------
NTSTATUS __stdcall DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)
{
  security_cookie_setup();                      // _security_cookie setup
  return DriverInitialization(DriverObject);
}

//----- (000000014000724C) ----------------------------------------------------
uintptr_t sub_14000724C()
{
  if ( !_security_cookie || _security_cookie == 0x2B992DDFA232LL )
    __fastfail(6u);
  qword_140004018 = ~_security_cookie;
  return ~_security_cookie;
}
// 140004018: using guessed type __int64 qword_140004018;

// nfuncs=45 queued=35 decompiled=35 lumina nreq=0 worse=0 better=0
#error "There were 1 decompilation failure(s) on 35 function(s)"
